// This file was generated by counterfeiter
package claimerfakes

import (
	"sync"
)

type FakeSlackClient struct {
	ListenStub        func(messageHandler func(text, channel, username string)) error
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		messageHandler func(text, channel, username string)
	}
	listenReturns struct {
		result1 error
	}
	listenReturnsOnCall map[int]struct {
		result1 error
	}
	PostMessageStub        func(channel, message string) error
	postMessageMutex       sync.RWMutex
	postMessageArgsForCall []struct {
		channel string
		message string
	}
	postMessageReturns struct {
		result1 error
	}
	postMessageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSlackClient) Listen(messageHandler func(text, channel, username string)) error {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		messageHandler func(text, channel, username string)
	}{messageHandler})
	fake.recordInvocation("Listen", []interface{}{messageHandler})
	fake.listenMutex.Unlock()
	if fake.ListenStub != nil {
		return fake.ListenStub(messageHandler)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.listenReturns.result1
}

func (fake *FakeSlackClient) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeSlackClient) ListenArgsForCall(i int) func(text, channel, username string) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return fake.listenArgsForCall[i].messageHandler
}

func (fake *FakeSlackClient) ListenReturns(result1 error) {
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSlackClient) ListenReturnsOnCall(i int, result1 error) {
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSlackClient) PostMessage(channel string, message string) error {
	fake.postMessageMutex.Lock()
	ret, specificReturn := fake.postMessageReturnsOnCall[len(fake.postMessageArgsForCall)]
	fake.postMessageArgsForCall = append(fake.postMessageArgsForCall, struct {
		channel string
		message string
	}{channel, message})
	fake.recordInvocation("PostMessage", []interface{}{channel, message})
	fake.postMessageMutex.Unlock()
	if fake.PostMessageStub != nil {
		return fake.PostMessageStub(channel, message)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postMessageReturns.result1
}

func (fake *FakeSlackClient) PostMessageCallCount() int {
	fake.postMessageMutex.RLock()
	defer fake.postMessageMutex.RUnlock()
	return len(fake.postMessageArgsForCall)
}

func (fake *FakeSlackClient) PostMessageArgsForCall(i int) (string, string) {
	fake.postMessageMutex.RLock()
	defer fake.postMessageMutex.RUnlock()
	return fake.postMessageArgsForCall[i].channel, fake.postMessageArgsForCall[i].message
}

func (fake *FakeSlackClient) PostMessageReturns(result1 error) {
	fake.PostMessageStub = nil
	fake.postMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSlackClient) PostMessageReturnsOnCall(i int, result1 error) {
	fake.PostMessageStub = nil
	if fake.postMessageReturnsOnCall == nil {
		fake.postMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSlackClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.postMessageMutex.RLock()
	defer fake.postMessageMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSlackClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
